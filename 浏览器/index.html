<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>浏览器 | Notes</title>
    <meta name="description" content="好记性不如烂笔头">
    
    
    <link rel="preload" href="/notes/assets/css/0.styles.8eca5996.css" as="style"><link rel="preload" href="/notes/assets/js/app.bcd0d301.js" as="script"><link rel="preload" href="/notes/assets/js/2.d69de630.js" as="script"><link rel="preload" href="/notes/assets/js/14.450aca5c.js" as="script"><link rel="prefetch" href="/notes/assets/js/10.20f09150.js"><link rel="prefetch" href="/notes/assets/js/11.c1051557.js"><link rel="prefetch" href="/notes/assets/js/12.d5cf140b.js"><link rel="prefetch" href="/notes/assets/js/13.5cad58bd.js"><link rel="prefetch" href="/notes/assets/js/15.9e24335f.js"><link rel="prefetch" href="/notes/assets/js/16.211079ae.js"><link rel="prefetch" href="/notes/assets/js/17.5cdae08a.js"><link rel="prefetch" href="/notes/assets/js/3.da26cf7d.js"><link rel="prefetch" href="/notes/assets/js/4.82f9c678.js"><link rel="prefetch" href="/notes/assets/js/5.4f064c30.js"><link rel="prefetch" href="/notes/assets/js/6.c82af6b1.js"><link rel="prefetch" href="/notes/assets/js/7.dea119d4.js"><link rel="prefetch" href="/notes/assets/js/8.dd67ac71.js"><link rel="prefetch" href="/notes/assets/js/9.fb41606c.js">
    <link rel="stylesheet" href="/notes/assets/css/0.styles.8eca5996.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/notes/" class="home-link router-link-active"><!----> <span class="site-name">Notes</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/notes/CSS/" class="sidebar-link">CSS</a></li><li><a href="/notes/JS/" class="sidebar-link">JS</a></li><li><a href="/notes/React/" class="sidebar-link">React</a></li><li><a href="/notes/%E6%8E%A2%E7%B4%A2React%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" class="sidebar-link">探索React最佳实践</a></li><li><a href="/notes/Typescript/" class="sidebar-link">TypeScript</a></li><li><a href="/notes/Webpack4/" class="sidebar-link">Webpack4</a></li><li><a href="/notes/%E6%B5%8F%E8%A7%88%E5%99%A8/" class="active sidebar-link">浏览器</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/notes/%E6%B5%8F%E8%A7%88%E5%99%A8/#跨域" class="sidebar-link">跨域</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/notes/%E6%B5%8F%E8%A7%88%E5%99%A8/#jsonp" class="sidebar-link">JSONP</a></li><li class="sidebar-sub-header"><a href="/notes/%E6%B5%8F%E8%A7%88%E5%99%A8/#cors" class="sidebar-link">CORS</a></li><li class="sidebar-sub-header"><a href="/notes/%E6%B5%8F%E8%A7%88%E5%99%A8/#代理" class="sidebar-link">代理</a></li><li class="sidebar-sub-header"><a href="/notes/%E6%B5%8F%E8%A7%88%E5%99%A8/#document-domain" class="sidebar-link">document.domain</a></li><li class="sidebar-sub-header"><a href="/notes/%E6%B5%8F%E8%A7%88%E5%99%A8/#postmessage" class="sidebar-link">postMessage</a></li></ul></li><li class="sidebar-sub-header"><a href="/notes/%E6%B5%8F%E8%A7%88%E5%99%A8/#javascript-运行机制" class="sidebar-link">JavaScript 运行机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/notes/%E6%B5%8F%E8%A7%88%E5%99%A8/#进程与线程" class="sidebar-link">进程与线程</a></li><li class="sidebar-sub-header"><a href="/notes/%E6%B5%8F%E8%A7%88%E5%99%A8/#任务队列-task-queue" class="sidebar-link">任务队列(task queue)</a></li></ul></li><li class="sidebar-sub-header"><a href="/notes/%E6%B5%8F%E8%A7%88%E5%99%A8/#event-loop-事件循环" class="sidebar-link">Event loop (事件循环)</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/notes/%E6%B5%8F%E8%A7%88%E5%99%A8/#微任务-microtask-和-宏任务-macrotask" class="sidebar-link">微任务(microtask) 和 宏任务(macrotask)</a></li><li class="sidebar-sub-header"><a href="/notes/%E6%B5%8F%E8%A7%88%E5%99%A8/#event-loop-顺序" class="sidebar-link">Event loop 顺序</a></li></ul></li></ul></li><li><a href="/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="sidebar-link">设计模式</a></li><li><a href="/notes/%E9%87%8D%E6%9E%84/" class="sidebar-link">重构</a></li><li><a href="/notes/%E6%9C%89%E8%B6%A3%E7%9A%84%E9%97%AE%E9%A2%98/" class="sidebar-link">有趣的问题</a></li><li><a href="/notes/Others/" class="sidebar-link">Others</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="浏览器"><a href="#浏览器" aria-hidden="true" class="header-anchor">#</a> 浏览器</h1> <h2 id="跨域"><a href="#跨域" aria-hidden="true" class="header-anchor">#</a> 跨域</h2> <p>出于安全考虑，有<a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" target="_blank" rel="noopener noreferrer">浏览器的同源策略<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，简单讲是浏览器为了防止以下情况的发生：</p> <p>你登录了某网站A，服务端判定登录成功后在响应头加入了 <code>Set-Cookie</code> 字段，下次发送请求时浏览器会自动将 <strong>cookie</strong> 附加到请求的头字段 <code>Cookie</code> 中，如果这时候你访问了网站B且网站B向A发送请求，由于没有同源策略的限制，网站B就相当于登录了你网站A的账号。</p> <h3 id="jsonp"><a href="#jsonp" aria-hidden="true" class="header-anchor">#</a> JSONP</h3> <p>利用 <code>script</code> 标签没有跨域限制，通过它指向请求的地址并且提供回调函数接收数据：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">&quot;http://domain/api?param1=a&amp;param2=b&amp;callback=jsonp&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
  <span class="token keyword">function</span> <span class="token function">jsonp</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre></div><p>JSONP 优点是是兼容性好，缺点是只能发送 <code>GET</code> 请求</p> <h3 id="cors"><a href="#cors" aria-hidden="true" class="header-anchor">#</a> CORS</h3> <p>服务端设置 <code>Access-Control-Allow-Origin</code></p> <h3 id="代理"><a href="#代理" aria-hidden="true" class="header-anchor">#</a> 代理</h3> <p>发送请求还是使用前端地址，然后通过代理把请求转发至需要的后端地址上。通常使用 Nginx 转发</p> <h3 id="document-domain"><a href="#document-domain" aria-hidden="true" class="header-anchor">#</a> document.domain</h3> <p>该方式只能用于二级域名相同的情况下，比如 <em>a.test.com</em> 和 <em>b.test.com</em> 适用于该方式。
只需要给页面添加 <code>document.domain = 'test.com'</code> 表示二级域名都相同就可以实现跨域</p> <h3 id="postmessage"><a href="#postmessage" aria-hidden="true" class="header-anchor">#</a> postMessage</h3> <p>这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 发送消息端</span>
window<span class="token punctuation">.</span>parent<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span> <span class="token string">'http://test.com'</span><span class="token punctuation">)</span>
<span class="token comment">// 接收消息端</span>
<span class="token keyword">var</span> mc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
mc<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span> <span class="token parameter">event</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> origin <span class="token operator">=</span> event<span class="token punctuation">.</span>origin <span class="token operator">||</span> event<span class="token punctuation">.</span>originalEvent<span class="token punctuation">.</span>origin
  <span class="token keyword">if</span> <span class="token punctuation">(</span>origin <span class="token operator">===</span> <span class="token string">'http://test.com'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'验证通过'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="javascript-运行机制"><a href="#javascript-运行机制" aria-hidden="true" class="header-anchor">#</a> JavaScript 运行机制</h2> <h3 id="进程与线程"><a href="#进程与线程" aria-hidden="true" class="header-anchor">#</a> 进程与线程</h3> <p>在浏览器中，打开一个 Tab 页就创建了一个新的进程，每个进程内可以存在多个线程（同一时间只能做一件事）：渲染线程、JS 引擎线程、HTTP 请求线程等。发起一个 HTTP 请求实际上会创建一个线程，请求结束后这个线程可能被销毁。</p> <p>JS 运行可能阻止渲染，因为这两个线程<strong>互斥</strong>，互斥的原因是 JS 可能会操作 DOM，这可能会使得渲染出现问题。</p> <blockquote><p>为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。</p></blockquote> <h3 id="任务队列-task-queue"><a href="#任务队列-task-queue" aria-hidden="true" class="header-anchor">#</a> 任务队列(task queue)</h3> <p>单线程意味着所有任务都要排队执行，但是遇到 <code>AJAX</code> <code>setTimeout</code> 等异步操作时我们肯定不能等待它执行完再执行其他任务。</p> <p>于是任务分成了 同步任务 和 异步任务。</p> <blockquote><p>同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；</p> <p>异步任务指的是，不进入主线程、而进入&quot;任务队列&quot;（task queue）的任务，只有&quot;任务队列&quot;通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p></blockquote> <p>所以 JS 运行的机制变成了：</p> <ol><li>同步任务在主线程上执行，形成执行栈。</li> <li>执行栈之外存在一个任务队列，异步任务有了结果以后会在任务队列中放置一个事件。</li> <li>执行栈同步任务执行完毕后会读取任务队列，根据事件对应异步任务，异步任务结束等待进入主线程执行。</li> <li>主线程不断重复上面步骤。</li></ol> <p>换个角度讲，一些事件（鼠标点击、页面滚动等）发生时，都会进入任务队列，可以认为这些事件就是异步任务。</p> <h2 id="event-loop-事件循环"><a href="#event-loop-事件循环" aria-hidden="true" class="header-anchor">#</a> Event loop (事件循环)</h2> <p>JS引擎是单线程的，在某一个特定的时间内只能执行一个任务，并阻塞其他任务的执行。这样的话，用户不得不等待一个耗时的操作完成之后才能进行后面的操作，但是实际开发中我们却可以使用异步代码来解决问题，那么异步代码是如何在单线程内运行的呢？</p> <p>当异步方法如 <code>setTimeout</code> 或 <code>ajax</code> 执行时，会交给浏览器内核的其他模块去管理。当其他模块执行完毕时将方法推入到一个任务队列(task queue)，当主线程代码执行完毕处于空闲时会检查任务队列，将任务队列中第一个任务入栈执行，执行完毕后继续检查任务队列，如此循环。</p> <p>看以下代码</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script start'</span><span class="token punctuation">)</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script end'</span><span class="token punctuation">)</span>
</code></pre></div><p>虽然 <code>setTimeout</code> 延时为 0，但由以上内容我们可知 <code>setTimeout</code> 还是会在 <code>script end</code> 之后打印。</p> <h3 id="微任务-microtask-和-宏任务-macrotask"><a href="#微任务-microtask-和-宏任务-macrotask" aria-hidden="true" class="header-anchor">#</a> 微任务(microtask) 和 宏任务(macrotask)</h3> <p>在 ES6 规范中，<strong>microtask</strong> 称为 <strong>jobs</strong>，<strong>macrotask</strong> 称为 <strong>task</strong>。
微任务(microtask):</p> <ul><li>process.nextTick</li> <li>promise</li> <li>Object.observe</li> <li>MutationObserver</li></ul> <p>宏任务(macrotask):</p> <ul><li><p>script</p></li> <li><p>setTimeout</p></li> <li><p>setInterval</p></li> <li><p>setImmediate</p></li> <li><p>I/O</p></li> <li><p>UI rendering</p></li> <li><p><strong>宏任务</strong>是每次<strong>执行栈</strong>执行的代码（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）</p></li> <li><p>浏览器为了能够使得<strong>JS引擎线程</strong>与<strong>GUI渲染线程</strong>有序切换，会在当前<strong>宏任务</strong>结束之后，下一个<strong>宏任务</strong>执行开始之前，对页面进行重新渲染（宏任务 &gt; 渲染  &gt; 宏任务 &gt; ...）</p></li> <li><p><strong>微任务</strong>是在当前<strong>宏任务</strong>执行结束之后立即执行的任务（在当前<strong>宏任务</strong>执行之后，UI渲染之前执行的任务）。<strong>微任务</strong>的响应速度相比<code>setTimeout</code>（下一个<strong>宏任务</strong>）会更快，因为无需等待UI渲染。</p></li> <li><p>当前<strong>宏任务</strong>执行后，会将在它执行期间产生的所有<strong>微任务</strong>都执行一遍。</p></li></ul> <h3 id="event-loop-顺序"><a href="#event-loop-顺序" aria-hidden="true" class="header-anchor">#</a> Event loop 顺序</h3> <ol><li>执行一个宏任务（script）</li> <li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li> <li>宏任务执行完毕后，立即执行当前微任务队列中的所有任务（依次执行）</li> <li>JS引擎线程挂起，GUI线程执行渲染</li> <li>GUI线程渲染完毕后挂起，JS引擎线程执行任务队列中的下一个宏任务</li></ol> <blockquote><p>简单点记，微任务是早于除去 <code>script</code> 的宏任务执行的。</p> <p>script =&gt; 微任务 =&gt; 其余宏任务</p></blockquote></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">9/10/2019, 11:55:35 AM</span></div></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/notes/assets/js/app.bcd0d301.js" defer></script><script src="/notes/assets/js/2.d69de630.js" defer></script><script src="/notes/assets/js/14.450aca5c.js" defer></script>
  </body>
</html>
